## Java常见面试题列表
1. `接口的意义`
    规范，可拓展，回调
2. `抽象类的意义`
    为其子类提供一个公共的类型，封装子类中重复的内容，定义抽象方法，子类虽然有不同的实现，但是定义是一致的
3. `内部类的作用`
    内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
    在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
    创建内部类对象的时刻并不依赖于外围类对象的创建。
    内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
    内部类提供了更好的封装，除了该外围类，其他类都不能访问
4. `父类的静态方法是否可以被子类重写`
    static静态的方法是属于类的，而继承和重写是相对于对象来说的。
    如果子类中有父类中的静态方法，只能说是隐藏父类的静态方法
5. `java虚拟机的特性`
    一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码的，而引入了java虚拟机后，java代码在不同的
    平台上运行不需要重新编译
6. `哪些情况下的对象会被垃圾回收机制处理掉`
    Java垃圾回收机制最基本的做法是分代回收，内存中的区域被划分成成不同的世代，`年轻`,`年老`，`永久`，当一个对象存活时间足够久的时候
    就会被复制到年老代中，对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。
7. `== 和 equals 的区别`
    == 是一个操作符  而equals是一个方法，并且这个方法是Object中的方法，我们可以通过重写来equals方法来实现我们自己的比较逻辑
8. `为什么说对象的equals方法比较为true，那么他们的hashcode方法返回的int值也要相同？`
    如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。
    如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果
    从而在集合操作的时候有如下规则：
    将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。
    回过来说get的时候，HashMap也先调key.hashCode()算出数组下标，然后看equals如果是true就是找到了，所以就涉及equals
9. `String , StringBuffer , StringBuilder`
    String : 字符串常量
    StringBuffer , StringBuilder ：字符串变量
10. `Java多态的理解`
    多态存在的三个必要条件:
        1. 要有继承
        2. 要有重写
        3. 父类引用指向子类对象
11. `线程的阻塞`
12. `里氏替换原则`
     子类不能重写父类已经实现的方法
     子类重写父类的方法时，返回值必须比父类更严格
13. try...finally  try中有return时的执行顺序
    首先finally代码块里的代码是一定会执行的
        1. 如果try中有return语句，会先将return的结果保存起来，然后执行finally中的代码，如果在finally中改变了要return
            的数据的值，也不会影响到return的值
        2. 如果在finally中写了return语句，那么就会返回return的值
14. 常见的异常
    - ArithmeticException（算术异常）
    - ClassCastException （类转换异常）
    - IllegalArgumentException （非法参数异常）
    - IndexOutOfBoundsException （下标越界异常）
    - NullPointerException （空指针异常）
15. `面向对象6原则一法则`
     `单一职责原则` : `说的就是高内聚，一个类只应该做一件事`
     `开闭原则` ： 对拓展开发，对修改关闭 ，想要表达的意思是：`把可能会修改的地方抽象出来(接口)，具体的实现是可以改变和拓展的`
     `里氏替换原则` : 在用到父类的地方一定可用其子类代替，想要表达的是：`同一个继承体系中的对象应该具有共同的行为特征`
     `依赖注入原则` ：要依赖抽象，不要依赖具体的实现，为了实现这个原则，就要求我们在编程的时候针对抽象类或者接口编程
     `接口分离`：不应该强迫程序依赖他们不需要的接口 `一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。`
     `迪米特法则` ：一个对象应该对象其他对象尽量少的了解，意思是要我们降低程序的耦合度

16. `sleep() 和 wait()的区别`
    sleep()会让出cpu的执行时间一段时间，但是不会释放锁，如果在同步的环境中，有可能出现死锁
    wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行
17. `什么时候使用同步`
     当多个线程使用一个共享资源时，使用同步
18. `什么时候使用异步`
     当一个操作需要会费很长的时间去做,并且不希望让程序等待方法的返回时,采用异步,这样效率更高
19. `什么是内存泄漏`
     程序员创建了一个对象，以后一直不使用这个对象了，但是这个对象一直被引用，即这个对象无用但是却无法被垃圾回收器回收
     例如：长生命周期的对象持有短生命周期对象的引用可能会发生内存泄漏，
          一个外部类对象返回了一个内部类的对象，这个内部类对象一直被引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露
